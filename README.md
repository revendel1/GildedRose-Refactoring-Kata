# GildedRose Refactoring in Ruby

Рефакторинг на Ruby исходного кода задачи [Gilded Rose](https://github.com/emilybache/GildedRose-Refactoring-Kata).
Условие задачи: [Ссылка](https://github.com/emilybache/GildedRose-Refactoring-Kata/blob/master/GildedRoseRequirements_ru.txt).
<br><br>

Исходный код программы расположен в файле [gilded_rose_original.rb](https://github.com/revendel1/GildedRose-Refactoring-Kata/blob/main/gilded_rose_original.rb). Основными проблемами данного кода является избыточная длина и глубокая вложенность метода update_quality в классе GildedRose из-за большого количества различных условий. Кроме того, вся бизнес-логика проекта сосредоточен в этом одном методе. В ходе анализа предметной области задачи установлено, что существует несколько типов товаров, каждый из которых обладает своими собственными чертами (разная величина изменения значения атрибута quantity) и в то же время они все имеют что-то общее (одинаковые атрибуты). Это наталкивает на идею использования наследования между классами, созданными для каждого типа товара, где каждый класс будет содержать свою собственную бизнес-логику. В такой архитектуре исходный класс Item рассматривается, как класс-родитель. Далее созданы подклассы, один из которых CommonItem для обычных товаров, у которых уменьшается срок годности и изменяется значение качества, и подкласс LegendaryItem для легендарных товаров, у которых не меняется качество и которые не имеют срока годности.
От класса CommonItem в свою очередь наследуются классы для товаров "Aged Brie", "Backstage passes" и "Conjured" для которых верно, что значение срока годности уменьшается на одно и то же значение, что и у класса CommonItem, но значение их качества изменяется своим собственным способом.
Иерархия созданной модели классов представлена ниже.
Работа с проектом реализуется путем создания объекта класса GildedRose, представляющего собой нашу гостиницу, имеющую свою собственную лавку товаров Items. В конструктор создаваемого объекта нужно передать массив объектов класса Items. Для каждого элемента данного массива с помощью модуля TypesParser будет найден соответствующий ему класс разработанной иерархии, содержащий всю необходимую логику для данного элемента. Данное решение принято с целью не изменять существующее соглашение об инициализации объекта класса GildedRose, конструктор которого в исходном коде принимает в качестве аргумента массив объектов класса Item. С помощью метода update_quality можно обновить значение качества и срока годности для каждого из товаров гостиницы GildedRose. Также добавлена возможность добавления нового товара(метод add_item класса GildedRose) в ходе работы над заданием по добавлению нового функционала, в случае если ассортимент товаров гостиницы будет продолжать меняться в дальнейшем (в условии, например, сказано что гостиница нашла поставщика новых товаров). Геттер добавлен с целью удобства получения текущих товаров гостиницы и их значений в случае, если сеть гостиниц будет в дальнейшем расширяться и в связи с этим будут созданы новые экземпляры класса GildedRose, что сделает проблематичным обращение к нужным объектам класса Item или его потомков.  

<br><br>
## Окружение
- Проект разрабатывается на языке Ruby версии 3.2.1
- Зависимости проекта:
  - rspec v3.12.0,
  - rubocop v1.57.2,
  - rubocop-rspec v2.25.0,
  - simplecov v0.22.0,
  - simplecov-console v0.9.1
- Группы зависимостей:
  - :development
  - :test
- Версия Bundler: 2.4.17
- Платформа: x86_64-linux.

## Установка
1. Установите Ruby:
Если у Вас еще нет Ruby на своей системе, убедитесь, что Ruby установлен. Вы можете скачать и установить Ruby с официального [веб-сайта Ruby](https://www.ruby-lang.org/).
2. Установите Bundler
```
gem install bundler
```
3. Скопируйте проект
```
https://github.com/revendel1/GildedRose-Refactoring-Kata.git
```
4. Перейдите в директорию проекта
```
cd GildedRose-Refactoring-Kata
```
5. Установите зависимости
```
bundle install
```

## Использование
1. Создайте новый файл с расширением .rb, либо запустите оболочку IRB командой
```
irb
```
2. Подключите используемые файлы
```
require './lib/gilded_rose'
require './lib/types_parser'
require './lib/item'
```
3. Создайте массив объектов класса Item, указав для каждого из них его имя, срок годности и качество
Например:
```
items = [
  Item.new(name="Aged Brie", sell_in=2, quality=0),
  Item.new(name="Elixir of the Mongoose", sell_in=5, quality=7),
  Item.new(name="Sulfuras, Hand of Ragnaros", sell_in=0, quality=80),
]
```
4. Создайте экземпляр класса GildedRose, передав в его конструктор созданный на предыдущем шаге массив
5. Вызовите метод `update_quality` у экземпляра GildedRose столько раз, сколько прошло дней
6. Обратившись к аттрибуту `items` экземпляра класса GildedRose можно увидеть, как поменялись значения качества товаров `quantity` и их срок годности `sell_in`.
<br><br>

Пример использования реализованного кода представлен в файле `texttest_fixture.rb`
Запустить его можно командой консоли `ruby texttest_fixture.rb`

![Run code](./img/run_code.png)

## Тесты

Запустить тесты можно командой:
```
bundle exec rspec
```
В консоль выведется результат прошедших тестов и процент их покрытия.
![Test Results](./img/tests_result.png)

## Диаграмма классов
![Diagram](./img/diagram.jpg)